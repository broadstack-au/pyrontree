# Benchmarking

### Rationale

1. All Tree implementations aren't equal. 
2. It's good to have a comparison.

### Libraries (python):

1. bigtree - Version : 0.9.5
    - Repo:
        - https://github.com/kayjan/bigtree
    - Doco:
        - https://bigtree.readthedocs.io/en/latest/
    - install cmd: 
        - pip install bigtree

2. treelib - Version : 1.6.4
    - Repo: 
        - https://github.com/caesar0301/treelib/blob/master/treelib/tree.py
    - Doco: 
        - https://treelib.readthedocs.io/en/latest/
    - install cmd: 
        - pip install treelib

3. simpletree3 - Version : 1.0.10
    - Repo:
        - https://github.com/arcombe012/simpletree3
    - Doco:
        - https://pypi.org/project/simpletree3/
    - install cmd: 
        - pip install simpletree3

### Libraries (rust):

4. id_tree - Version : 1.8.0
    - Repo:
        - https://github.com/iwburns/id-tree
    - Doco:
        - https://docs.rs/id_tree/latest/id_tree/
    - include in Cargo.toml:
        [dependencies]
        id_tree = "1.8.0"

### BenchMark Fucntions:

Are fairly scrappy.
Only track time, not memory.

1. Generate a tree with ~ 1000 Nodes, by randomly selecting existing nodes and adding a child to them.
2. Find all nodes in the tree once (of a tree generated by 1.).
3. Move 30 randomly selected Nodes around in the tree (to random locations in a tree generated by 1.).

### Results (Python):

1. Generate - 100 BenchMark Function Calls (each call generates a random tree with 1000 nodes)
    - bigtree_lib    took 0.5745145000 seconds, on average each run took 0.0057451450 seconds
    - tree_lib       took 0.2648852500 seconds, on average each run took 0.0026488525 seconds
    - simpletree_lib took 0.1415566250 seconds, on average each run took 0.0014155662 seconds
    - anytree_lib    took 0.2270340830 seconds, on average each run took 0.0022703408 seconds

2. Find - 100 BenchMark Function Calls (each call finds EVERY node in the tree, once)
    - bigtree_lib    took 29.8481149580 seconds, on average each run took 0.2984811496 seconds
    - tree_lib       took 0.2721500830 seconds, on average each run took 0.0027215008 seconds
    - simpletree_lib took 28.6300255830 seconds, on average each run took 0.2863002558 seconds
    - anytree_lib    took 38.2622381250 seconds, on average each run took 0.3826223813 seconds
        -note: anytree is returning multiple entries for anytree.find and errors out (it checks to make sure it's only returning one)
        -      this test runs anytree.findall which means it does a full traversal every time.

3. Move - 33 BenchMark Function Calls (each call moves 30 nodes to random locations)
    - bigtree_lib    took 0.1900671670 seconds, on average each run took 0.0057596111 seconds
    - tree_lib       took 0.0924006250 seconds, on average each run took 0.0028000189 seconds
    - simpletree_lib took 0.0481395410 seconds, on average each run took 0.0014587740 seconds
    - anytree_lib    took 0.0793578750 seconds, on average each run took 0.0024047841 seconds
        -note: see above note on anytree.find

### Results (Rust):

Note: the Rust benchmark packa isn't particularly transparent with what's going on.

1. Generate (currently no payload) - ?? BenchMark Function Calls (each call generates a random tree with 1000 nodes)
    - id_tree took 74,208 ns/iter (+/- 3,082) ~0.000074208 seconds (roughly 18x faster than fastest python version, ~40x faster than the slowest)

2. Find - ?? BenchMark Function Calls (each call finds EVERY node in the tree, once)
    - id_tree took 75,450 ns/iter (+/- 5,890) ~0.000075450 seconds (roughly 50x faster than the fastest python - ~5000x faster than the slowest)

3. Move - TBD

### Notes:

1. Tree_lib implements a dictionary lookup for retrieving the nodes by ID, all other libraries are doing a tree traversal. (I'm pretty sure I haven't buggered up the benchmark function).

From: https://github.com/caesar0301/treelib/blob/master/treelib/tree.py 

    line 507:
        def get_node(self, nid):
            """
            Get the object of the node with ID of ``nid``.

            An alternative way is using '[]' operation on the tree. But small difference exists between them:
            ``get_node()`` will return None if ``nid`` is absent, whereas '[]' will raise ``KeyError``.
            """
            if nid is None or not self.contains(nid):
                return None
            return self._nodes[nid]
        
    line 83: 
        #: dictionary, identifier: Node object
        self._nodes = {}